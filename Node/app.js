/*
  Author: 	Cameron Palk
  Date:   	September 2016
  Version: 	1.0.0
*/

'use strict';

// NPM
const
  express    = require('express'),
  bodyParser = require('body-parser'),
  config     = require('config'),
  crypto     = require('crypto'),
  request    = require('request'),
  { Wit, log }    = require('node-wit');

// Local
const
  exampleQs  = require('./resources/example-qs.json');




// Express App
var app = express();



// App middleware
app.use(bodyParser.json({ verify: verifyRequestSignature }));
app.use(express.static('public'));

// Port definied by Modulus host, local testing on :5000
app.set('PORT', process.env.PORT || 5000);



/** FACEBOOK MESSENGER SECRETS
 * 		MES_APP_SECRET:         On App Dashoard https://developers.facebook.com/apps/1762589327347412/dashboard/
 *   	MES_VALIDATION_TOKEN:   Generated by me, used in Webhook validation
 *    MES_PAGE_ACCESS_TOKEN:  On App Dashboard, used to connect to correct Facebook page
*/
const
  MES_APP_SECRET        = process.env.MESSENGER_APP_SECRET ||
                          config.get('messenger.appSecret'),
  MES_VALIDATION_TOKEN  = process.env.MESSENGER_VALIDATION_TOKEN ||
                          config.get('messenger.validationToken'),
  MES_PAGE_ACCESS_TOKEN = process.env.MESSENGER_PAGE_ACCESS_TOKEN ||
                          config.get('messenger.pageAccessToken');


/** WIT.AI SECRETS
 * 		WIT_SERVER_ACCESS_TOKEN: On Settings page of Wit.ai App
*/
const
  WIT_SERVER_ACCESS_TOKEN = process.env.WITAI_SERVER_ACCESS_TOKEN ||
                            config.get('witai.serverAccessToken');

/** PUBLIC SERVER URL */
const
  SERVER_URL = process.env.SERVER_URL || config.get('serverURL');



// Ensure these required values have been found
if (!(MES_APP_SECRET && MES_VALIDATION_TOKEN && MES_PAGE_ACCESS_TOKEN && WIT_SERVER_ACCESS_TOKEN && SERVER_URL)) {
  console.error("Missing config values");
  process.exit(1);
}
else {
  console.log("MES_APP_SECRET         ", MES_APP_SECRET,
            "\nMES_VALIDATION_TOKEN   ", MES_VALIDATION_TOKEN,
            "\nMES_PAGE_ACCESS_TOKEN  ", MES_PAGE_ACCESS_TOKEN.substr(0,30)+'..',
            "\nWIT_SERVER_ACCESS_TOKEN", WIT_SERVER_ACCESS_TOKEN.substr(0,30)+'..',
            "\nSERVER_URL:            ", SERVER_URL);
}


// ----------------------------------------------------------------------------
// Wit.ai bot

// Track client sessions with context
// { sessionId : {fbid: facebookUserId, context: sessionState} }
const sessions = {};


function findOrCreateSession(fbid) {
  let sessionId;
  Object.keys(sessions).forEach(key => {
    if (sessions[key].fbid == fbid) {
      sessionId = key;
    }
  });
  if (!sessionId) {
    sessionId = new Date().toISOString();
    sessions[sessionId] = {fbid: fbid, context: {}};
  }
  return sessionId;
}

function extractConfidence(entities) {
  const confidence = entities.intent[0].confidence;
  if (confidence) {
    return confidence;
  } else {
    console.error(`Could not find a confidence score.`);
  }
}

function randomArrayIndex(listLength) {
  return Math.floor(Math.random() * listLength);
}



// Bot Actions
const actions = {

  send({sessionId}, {text}) {
    const recipientId = sessions[sessionId].fbid;
    if (recipientId) {
      // Forward our bot response
      // Return a promise when done sending
      return new Promise((resolve, reject) => {
        sendTextMessage(recipientId, text);
      }).catch(console.error);

    } else {
      console.error(`Couldn't find user for session: ${sessionId}`);
      return Promise.resolve();
    }
  },

  // Custom Action handling here

  showHelp({sessionId, context, text, entities}) {
    return new Promise((resolve, reject) => {

      const confidence = extractConfidence(entities);
      console.log(`Show help came back with ${confidence * 100}% confidence`);

      // We can check if they've asked for help a lot and
      // send them to a rep. if necessary

      // Grabbing a random example query for the users help message
      // Adding it to the current context
      const exampleQuery = exampleQs.help[randomArrayIndex(exampleQs.help.length)] ||
                            "I'm looking for some fresh nail art ideas!"; // Default example
      const newContext = Object.assign({exampleQuery}, context);

      return resolve(newContext);
    });
  },

  updateCategory({sessionId, context, text, entities}) {
    return new Promise((resolve, reject) => {
      const category = entities.intent[0].value;
      const newContext = Object.assign({category, 'Yes':true}, context);
      return resolve(newContext);
    });
  },

  findStylist({sessionId, context, text, entities}) {
    return new Promise((resolve, reject) => {
      console.log(`Find stylist called with context: ${JSON.stringify(context)}`);
      sendTextMessage(sessions[sessionId].fbid, '~ DISPLAY STYLIST RESULTS ~');
      return resolve(context);
    })
  },

};




const wit_client = new Wit({
  accessToken: WIT_SERVER_ACCESS_TOKEN,
  actions,
  logger: new log.Logger(log.DEBUG)
});












/* FACEBOOK WEBHOOK VERIFICATION
*/
app.get('/webhook', (req, res) => {
  if (req.query['hub.mode'] === 'subscribe' &&
      req.query['hub.verify_token'] === MES_VALIDATION_TOKEN) {
    console.log('Validating Webhook');
    res.status(200).send(req.query['hub.challenge']);
  } else {
    console.error('Failed webhook validation. Ensure validation tokens match');
    res.sendStatus(403);
  }
});



/* HANDLE MESSENGER EVENTS
*/
app.post('/webhook', (req, res) => {
  const data = req.body;

  if (data.object == 'page') {
    // Iterate over each page entry
    data.entry.forEach((pageEntry) => {
      const pageID      = pageEntry.id;
      const timeOfEvent = pageEntry.time;

      // Iterate over each message from page
      pageEntry.messaging.forEach((messagingEvent) => {
        if      (messagingEvent.optin)            { receivedAuthenticationEvent(messagingEvent);        }
        else if (messagingEvent.message)          { receivedMessageEvent(messagingEvent);               }
        else if (messagingEvent.delivery)         { receivedDeliveryConfirmationEvent(messagingEvent);  }
        else if (messagingEvent.postback)         { receivedPostbackEvent(messagingEvent);              }
        else if (messagingEvent.read)             { receivedReadReceiptEvent(messagingEvent);           }
        else if (messagingEvent.account_linking)  { receivedAccountLinkEvent(messagingEvent);           }
        else { console.log('Webhook recieved unknown messaging event:', messagingEvent); }
      });

    });

    // Facebook requires <20 second successful response, otherwise the request will time out
    res.sendStatus(200);
  }
});


/* CALLBACK HANDLERS */


/** Message Event
 * 		Event called when a message is sent to your page.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-received
*/
function receivedMessageEvent(event) {
  const senderID    = event.sender.id;
  const recipientID = event.recipient.id;
  const timestamp   = event.timestamp;

  // Retrieve or create a session for the user
  const sessionID = findOrCreateSession(senderID);

  // Unwrap the content of the message
  const {is_echo, text, attachments} = event.message;

  if (attachments) {
    sendTextMessage(senderID, `Sorry, I can only process text for now.`)
  } else if (text) {
    // Text message recieved

    if (is_echo) {
      // This sender is the wit bot
      return;
    }

    // Forward the message to wit.ai bot if the senderID is not the bots senderID
    // This runs all actions until our bot has nothing left to do
    wit_client.runActions(
      sessionID,
      text,
      sessions[sessionID].context
    ).then((context) => {
      // The bot has done everything it has to do
      // Now it's waiting for further message to proceed.
      console.log(`Waiting for next user message with context: ${JSON.stringify(context)}`);

      // Update context state if needed
      sessions[sessionID].context = context;
    })
    .catch((err) => {
      console.error(`Got an error from Wit: ${err.stack || err}`);
    });
  } else {
    console.log(`recieved event ${JSON.stringify(event)}`);
  }

}




/** Authorization Event
 * 		Used with the 'Send to messenger' plugin.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/authentication
*/
function receivedAuthenticationEvent(event) {
  console.error("Authorization event not yet implemented.");
}


/** Deliever Confirmation Event
 * 		Sent to confirm delivery of a message.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-delivered
*/
function receivedDeliveryConfirmationEvent(event) {
  console.log("Delivery confirmation recieved from user id", event.sender.id);
}


/** Postback Event
 * 		Postback tapped on Structured Messages.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/postback-received
*/
function receivedPostbackEvent(event) {
  console.error("Postbacks are not yet implemented.");
}


/** Read Receipt Event
 * 		Called when a previously-sent message has been read.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-read
*/
function receivedReadReceiptEvent(event) {
  console.log("Messege read by user id", event.sender.id);
}


/** Account Linking Event
 * 		When Link Account or Unlink Account action is tapped.
 * 		https://developers.facebook.com/docs/messenger-platform/webhook-reference/account-linking
*/
function receivedAccountLinkEvent(event) {
  console.error("Account Linking is not yet implemented.");
}





/* MESSAGE SENDING */


/** Send Text Message
 * 		Send a text message using the Send API.
*/
function sendTextMessage(recipientId, messageText) {
  const messageData = {
    recipient: {
      id: recipientId
    },
    message: {
      text: messageText,
      metadata: "Metadata placeholder"
    }
  }

  callSendAPI(messageData);
}


/** Send API
 * 		Call the Send API. On success, we get message id in a response.
*/
function callSendAPI(messageData) {

  const requestData = {
    uri: 'https://graph.facebook.com/v2.6/me/messages',
    qs: { access_token: MES_PAGE_ACCESS_TOKEN },
    method: 'POST',
    json: messageData
  }

  request(requestData, (error, response, body) => {
    if (!error && response.statusCode == 200) {
      const recipientId = body.recipient_id;
      const messageId = body.message_id;

      if (messageId) {
        // console.log('Successfully sent message with id %s to recipient %s', messageId, recipientId);
      } else {
        console.log('Successfully call Sent API for recipient %s', recipientId);
      }
    } else {
      console.error(response.error);
    }
  });
}



/* CALLBACK VERIFICATION */

/* Verify that the callback came from Facebook
*/
function verifyRequestSignature(req, res, buf) {
  const signature = req.headers['x-hub-signature'];

  if (!signature) {
    console.error('Couldn\'t locate request signature');
  } else {
    const [method, signatureHash] = signature.split('=');

    var expectedHash = crypto.createHmac('sha1', MES_APP_SECRET)
                        .update(buf)
                        .digest('hex');

    if (signatureHash != expectedHash) {
      throw new Error("Couldn't validate the request signature, expected hash does not match.");
    }
  }
}



/* START APPLICATION
*/
app.listen(app.get('PORT'), () => {
  console.log('Node app running on port', app.get('PORT'));
});
